import socket
import sys
import os
from Crypto.Cipher import AES
from Crypto.Hash import SHA256

#used to hash data and return hexdigest
def hasher(data):
    h = SHA256.new()
    h.update(data)
    return h.hexdigest()

#need to take in a key and IV instead of hardcoding
def encrypt_personal_data(filename):
    data = open(filename, "rb").read()
    encryption_suite = AES.new('This is my key!!', AES.MODE_CFB, 'This is my IV!!!')
    cipher_text = encryption_suite.encrypt(data)
    return cipher_text

#need to take in a key and IV instead of hardcoding
def decrypt_personal_data(data):
    decryption_suite = AES.new('This is my key!!', AES.MODE_CFB, 'This is my IV!!!')
    msg = decryption_suite.decrypt(data)
    return msg

#need to take in a key and IV instead of hardcoding
def encrypt(data):
    encryption_suite = AES.new('Sixteen byte key', AES.MODE_CFB, 'This is the IV!!')
    cipher_text = encryption_suite.encrypt(data)
    return cipher_text

#need to take in a key and IV instead of hardcoding
def decrypt(data):
    decryption_suite = AES.new('Sixteen byte key', AES.MODE_CFB, 'This is the IV!!')
    msg = decryption_suite.decrypt(data)
    return msg

#setup server role
def server():
    #create a socket to use
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_address = ('localhost', 8081)
    print >>sys.stderr,'starting up on the %s port %s' % server_address
    sock.bind(server_address)
    sock.listen(1)

    #loop to find connection requests
    while True:
        print >>sys.stderr, 'waiting for a connection'
        #accepts connection request from client
        connection, client_address = sock.accept()
        try:
            print >>sys.stderr, 'connection from', client_address

            #loop to receive messages from the client
            while True:
                #store message from client in data variable
                data = connection.recv(1024)
                print >>sys.stderr, '%s' % data

                if data == 'send':
                    incoming = connection.recv(1024)
                    incoming = decrypt(incoming)
                    #print(data)
                    filename = incoming[:64]
                    #print('This is the filename hash: ' + filename)
                    hash_value = incoming[64:128]
                    #print('This is the encrypted file hash: ' + hash_value)
                    incoming = incoming[128:]
                    #print('This is the encrypted file: ' + data)
                    hash_generated_by_server = hasher(incoming)
                    #print('This is the hash generated by the server: ' + hash_generated_by_server)
                    if hash_generated_by_server == hash_value:
                        #print("THEY MATCHED NEED TO STORE")
                        open(filename, "wb").write(incoming)
                    #print(data)
                    connection.sendall(incoming)
                    break
                elif data == 'retrieve':

                    print("trying to retrieve data")
                    requested_filename = connection.recv(1024)
                    if os.path.exists(requested_filename):
                        connection.sendall('found')
                    else:
                        connection.sendall('File not found, please try another name.')
                        break
                    file_data = open(requested_filename, "rb").read()
                    hash_of_req_file = hasher(requested_filename)
                    packet = hash_of_req_file + file_data
                    encrypted_packet = encrypt(packet)
                    connection.sendall(encrypted_packet)
                else:
                    break

        finally:
            connection.close()
        return

def send():
    while True:
        file_to_encrypt = raw_input('Enter the filename you would like to encrypt: ')
        if file_to_encrypt in ['exit', 'x']:
            return
        if os.path.exists(file_to_encrypt):
            break
        else:
            print('Please enter a valid filename.')
    filename_hash = hasher(file_to_encrypt)
    #print('This is the filename hash: ' + filename_hash)
    my_encrypted_file = encrypt_personal_data(file_to_encrypt)
    #print('This is the encrypted file: ' + my_encrypted_file)
    hash_value = hasher(my_encrypted_file)
    #print('This is the encrypted file hash: ' + hash_value)
    #print(my_encrypted_file)
    #print(hash_value)
    packet = filename_hash + hash_value + my_encrypted_file
    message = encrypt(packet)
    return message

#setup client role
#TO-DO need to write retrieve code, try to create more functions to reduce redundancy
def client():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    server_address = ('localhost', 8081)
    print >>sys.stderr, 'connecting to %s port %s' % server_address
    sock.connect(server_address)

    try:
        while True:
            choice = ''
            while choice not in ['send', 's', 'retrieve', 'r', 'exit', 'x']:
                choice = raw_input('Would you like to send or retrieve data? ').lower()
            if choice in ['exit', 'x']:
                break
            if choice in ['send', 's']:
                sock.sendall('send')
                sock.sendall(send())

            elif choice in ['retrieve', 'r']:
                while True:
                    filename = ''
                    sock.sendall('retrieve')
                    filename = raw_input('Enter the name of the file you would like to retrieve: ')
                    #print(filename)
                    hashed_filename = hasher(filename)
                    #print(hashed_filename)
                    sock.sendall(hashed_filename)

                    server_file_status = sock.recv(1024)
                    if server_file_status == 'found':
                        print(server_file_status)
                        requested_packet_data = sock.recv(1024)
                        print(requested_packet_data)
                        decrypted_packet = decrypt(requested_packet_data)
                        hash_value = decrypted_packet[:64]
                        personal_data = decrypted_packet[64:]
                        print(decrypt_personal_data(personal_data))
                        break
                    else:
                        print(server_file_status)
                        break

                    break

            #NEED TO HANDLE THE LENGTH CORRECTLY
            #amount_received = 0
            #amount_expected = len(message[128:])

            #while amount_received < amount_expected:
                #data = sock.recv(1024)
                #amount_received += len(data)
                #print(data)
                #msg = decrypt_personal_data(data)
                #print(msg)
                #print >>sys.stderr, data
    finally:
        print >>sys.stderr, 'closing socket'
        sock.close()
    return

#initializes an empty string to be used to validate role input
choice = ''
while choice not in ['server', 's', 'client', 'c']:
    choice = raw_input('Enter your role(server or client)').lower()

if choice in ['client', 'c']:
    client()
else:
    server()
